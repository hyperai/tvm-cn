
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Relay’s Type System &#8212; tvm-cn 1.0.0 文档</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="relay-s-type-system">
<h1>Relay’s Type System<a class="headerlink" href="#relay-s-type-system" title="永久链接至标题">¶</a></h1>
<p>We briefly introduced types while detailing Relay’s expression language,
but have not yet described its type system. Relay is
a statically typed and type-inferred language, allowing programs to
be fully typed while requiring just a few explicit type annotations.</p>
<p>Static types are useful when performing compiler optimizations because they
communicate properties about the data a program manipulates, such as runtime
shape, data layout, and storage, without needing to run the program.
Relay’s <a class="reference internal" href="#algebraic-data-types">Algebraic Data Types</a> allow for easily and flexibly composing
types in order to build data structures that can be
reasoned about inductively and used to write recursive functions.</p>
<p>Relay’s type system features a form of <em>dependent typing</em> for shapes. That is, its type system keeps track of the shapes of tensors in a Relay program. Treating tensor
shapes as types allows Relay to perform more powerful reasoning at compile time;
in particular, Relay can statically reason about operations whose output shapes
vary based on the input shapes in complex ways. Casting shape inference as a type
inference problem allows Relay to infer the shapes of all tensors at compile time,
including in programs that use branching and function calls.</p>
<p>Statically reasoning about shapes in this manner allows
Relay to be ahead-of-time compiled and provides much more information about
tensors for optimizations further in the compilation pipeline. Such optimizations
can be implemented as passes, which are Relay-to-Relay AST transformations, and
may use the inferred types (e.g., shape information) for making decisions about
program transformations. For instance, <code class="code docutils literal notranslate"><span class="pre">src/relay/transforms/fuse_ops.cc</span></code> gives
an implementation of a pass that uses inferred tensor shapes to replace invocations
of operators in a Relay program with fused operator implementations.</p>
<p>Reasoning about tensor types in Relay is encoded using <em>type relations</em>, which means
that the bulk of type checking in Relay is constraint solving (ensuring that all
type relations are satisfied at call sites). Type relations offer a flexible and
relatively simple way of making the power of dependent typing available in Relay
without greatly increasing the complexity of its type system.</p>
<p>Below we detail the language of types in Relay and how they are assigned to Relay expressions.</p>
<div class="section" id="type">
<h2>Type<a class="headerlink" href="#type" title="永久链接至标题">¶</a></h2>
<p>The base type for all Relay types. All Relay types are sub-classes of this base type.</p>
<p>See <code class="xref py py-class docutils literal notranslate"><span class="pre">Type</span></code> for its definition and documentation.</p>
</div>
<div class="section" id="tensor-type">
<h2>Tensor Type<a class="headerlink" href="#tensor-type" title="永久链接至标题">¶</a></h2>
<p>A concrete tensor type in Relay.</p>
<p>Tensors are typed according to data type and shape. At present, these use TVM’s
data types and shapes, but in the future, Relay may include a separate AST for
shapes. In particular, data types include <code class="code docutils literal notranslate"><span class="pre">bool</span></code>, <code class="code docutils literal notranslate"><span class="pre">float32</span></code>, <code class="code docutils literal notranslate"><span class="pre">int8</span></code> and various
other bit widths and numbers of lanes. Shapes are given as tuples of dimensions (TVM <code class="code docutils literal notranslate"><span class="pre">IndexExpr</span></code>),
such as <code class="code docutils literal notranslate"><span class="pre">(5,</span> <span class="pre">5)</span></code>; scalars are also given tuple types and have a shape of <code class="code docutils literal notranslate"><span class="pre">()</span></code>.</p>
<p>Note, though, that TVM shapes can also include variables and arithmetic expressions
including variables, so Relay’s constraint solving phase will attempt to find
assignments to all shape variables to ensure all shapes will be concrete before
running a program.</p>
<p>For example, here is a simple concrete tensor type corresponding to a 10-by-10 tensor of 32-bit floats:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Tensor</span><span class="p">[(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">float32</span><span class="p">]</span>
</pre></div>
</div>
<p>See <code class="xref py py-class docutils literal notranslate"><span class="pre">TensorType</span></code> for its definition and documentation.</p>
</div>
<div class="section" id="tuple-type">
<h2>Tuple Type<a class="headerlink" href="#tuple-type" title="永久链接至标题">¶</a></h2>
<p>A type of a tuple in Relay.</p>
<p>Just as a tuple is simply a sequence of values of statically known length, the type
of a tuple consists of a sequence of the types corresponding to each member of the tuple.</p>
<p>Because a tuple type is of statically known size, the type of a tuple projection
is simply the corresponding index into the tuple type.</p>
<p>For example, in the below code, <code class="code docutils literal notranslate"><span class="pre">%t</span></code> is of type
<code class="code docutils literal notranslate"><span class="pre">(Tensor[(),</span> <span class="pre">bool],</span> <span class="pre">Tensor[(10,</span> <span class="pre">10),</span> <span class="pre">float32])</span></code>
and <code class="code docutils literal notranslate"><span class="pre">%c</span></code> is of type <code class="code docutils literal notranslate"><span class="pre">Tensor[(10,</span> <span class="pre">10),</span> <span class="pre">float32]</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="o">%</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">float32</span><span class="p">));</span>
<span class="n">let</span> <span class="o">%</span><span class="n">c</span> <span class="o">=</span> <span class="o">%</span><span class="n">t</span><span class="o">.</span><span class="mi">1</span><span class="p">;</span>
<span class="o">%</span><span class="n">c</span>
</pre></div>
</div>
<p>See <code class="xref py py-class docutils literal notranslate"><span class="pre">TupleType</span></code> for its definition and documentation.</p>
</div>
<div class="section" id="type-parameter">
<span id="id1"></span><h2>Type Parameter<a class="headerlink" href="#type-parameter" title="永久链接至标题">¶</a></h2>
<p>Type parameters represent placeholder types used for polymorphism in functions.
Type parameters are specified according to <em>kind</em>, corresponding to the types
those parameters are allowed to replace:</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">Type</span></code>, corresponding to top-level Relay types like tensor types, tuple types, and function types</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">BaseType</span></code>, corresponding to the base type of a tensor (e.g., <code class="code docutils literal notranslate"><span class="pre">float32</span></code>, <code class="code docutils literal notranslate"><span class="pre">bool</span></code>)</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">Shape</span></code>, corresponding to a tensor shape</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">ShapeVar</span></code>, corresponding to variables within a tensor shape</p></li>
</ul>
<p>Relay’s type system enforces that type parameters are only allowed to appear where their kind permits them,
so if type variable <code class="code docutils literal notranslate"><span class="pre">t</span></code> is of kind <code class="code docutils literal notranslate"><span class="pre">Type</span></code>, <code class="code docutils literal notranslate"><span class="pre">Tensor[t,</span> <span class="pre">float32]</span></code> is not a valid type.</p>
<p>Like normal parameters, concrete arguments must be given for type parameters at call sites.</p>
<p>For example, <code class="code docutils literal notranslate"><span class="pre">s</span></code> below is a type parameter of kind <code class="code docutils literal notranslate"><span class="pre">Shape</span></code> and it will
be substituted with <code class="code docutils literal notranslate"><span class="pre">(10,</span> <span class="pre">10)</span></code> at the call site below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nd">@plus</span><span class="o">&lt;</span><span class="n">s</span> <span class="p">:</span> <span class="n">Shape</span><span class="o">&gt;</span><span class="p">(</span><span class="o">%</span><span class="n">t1</span> <span class="p">:</span> <span class="n">Tensor</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">float32</span><span class="p">],</span> <span class="o">%</span><span class="n">t2</span> <span class="p">:</span> <span class="n">Tensor</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">float32</span><span class="p">])</span> <span class="p">{</span>
     <span class="n">add</span><span class="p">(</span><span class="o">%</span><span class="n">t1</span><span class="p">,</span> <span class="o">%</span><span class="n">t2</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">plus</span><span class="o">&lt;</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>See <code class="xref py py-class docutils literal notranslate"><span class="pre">TypeVar</span></code> for its definition and documentation.</p>
</div>
<div class="section" id="type-constraint">
<h2>Type Constraint<a class="headerlink" href="#type-constraint" title="永久链接至标题">¶</a></h2>
<p>This is an abstract class representing a type constraint, to be elaborated
upon in further releases. Currently, type relations are the only
type constraints provided; they are discussed below.</p>
<p>See <code class="xref py py-class docutils literal notranslate"><span class="pre">TypeConstraint</span></code> for its definition and documentation.</p>
</div>
<div class="section" id="function-type">
<h2>Function Type<a class="headerlink" href="#function-type" title="永久链接至标题">¶</a></h2>
<p>A function type in Relay, see <cite>tvm/relay/type.h</cite> for more details.</p>
<p>This is the type assigned to functions in Relay. A function type
consists of a list of type parameters, a set of type constraints,
a sequence of argument types, and a return type.</p>
<p>We informally write function types as:
<code class="code docutils literal notranslate"><span class="pre">fn&lt;type_params&gt;(arg_types)</span> <span class="pre">-&gt;</span> <span class="pre">ret_type</span> <span class="pre">where</span> <span class="pre">type_constraints</span></code></p>
<p>A type parameter in the function type may appear in the argument
types or the return types. Additionally, each of the type constraints
must hold at every call site of the function. The type constraints
typically take the function’s argument types and the function’s return
type as arguments, but may take a subset instead.</p>
<p>See <code class="xref py py-class docutils literal notranslate"><span class="pre">FuncType</span></code> for its definition and documentation.</p>
</div>
<div class="section" id="type-relation">
<span id="id2"></span><h2>Type Relation<a class="headerlink" href="#type-relation" title="永久链接至标题">¶</a></h2>
<p>A type relation is the most complex type system feature in Relay.
It allows users to extend type inference with new rules.
We use type relations to define types for operators that work with
tensor shapes in complex ways, such as broadcasting operators or
<code class="code docutils literal notranslate"><span class="pre">flatten</span></code>, allowing Relay to statically reason about the shapes
in these cases.</p>
<p>A type relation <code class="code docutils literal notranslate"><span class="pre">R</span></code> describes a relationship between the input and output types of a Relay function.
Namely, <code class="code docutils literal notranslate"><span class="pre">R</span></code> is a function on types that
outputs <cite>true</cite> if the relationship holds and <cite>false</cite>
if it fails to hold. Types given to a relation may be incomplete or
include shape variables, so type inference must assign appropriate
values to incomplete types and shape variables for necessary relations
to hold, if such values exist.</p>
<p>For example we can define an identity relation to be:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">Identity</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span> <span class="nv">I</span><span class="p">)</span> <span class="p">:-</span> <span class="s s-Atom">true</span>
</pre></div>
</div>
<p>It is usually convenient to type operators
in Relay by defining a relation specific to that operator that
encodes all the necessary constraints on the argument types
and the return type. For example, we can define the relation for <code class="code docutils literal notranslate"><span class="pre">flatten</span></code>:</p>
<div class="highlight-prolog notranslate"><div class="highlight"><pre><span></span><span class="nv">Flatten</span><span class="p">(</span><span class="nv">Tensor</span><span class="p">(</span><span class="s s-Atom">sh</span><span class="p">,</span> <span class="s s-Atom">bt</span><span class="p">),</span> <span class="nv">O</span><span class="p">)</span> <span class="p">:-</span>
  <span class="nv">O</span> <span class="o">=</span> <span class="nv">Tensor</span><span class="p">(</span><span class="s s-Atom">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nf">prod</span><span class="p">(</span><span class="s s-Atom">sh</span><span class="p">[</span><span class="mi">1</span><span class="s s-Atom">:</span><span class="p">]))</span>
</pre></div>
</div>
<p>If we have a relation like <code class="code docutils literal notranslate"><span class="pre">Broadcast</span></code> it becomes possible
to type operators like <code class="code docutils literal notranslate"><span class="pre">add</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">add</span> <span class="p">:</span> <span class="n">fn</span><span class="o">&lt;</span><span class="n">t1</span> <span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">t2</span> <span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">t3</span> <span class="p">:</span> <span class="n">Type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">t3</span>
            <span class="n">where</span> <span class="n">Broadcast</span>
</pre></div>
</div>
<p>The inclusion of <code class="code docutils literal notranslate"><span class="pre">Broadcast</span></code> above indicates that the argument
types and the return type must be tensors where the shape of <code class="code docutils literal notranslate"><span class="pre">t3</span></code> is
the broadcast of the shapes of <code class="code docutils literal notranslate"><span class="pre">t1</span></code> and <code class="code docutils literal notranslate"><span class="pre">t2</span></code>. The type system will
accept any argument types and return type so long as they fulfill
<code class="code docutils literal notranslate"><span class="pre">Broadcast</span></code>.</p>
<p>Note that the above example relations are written in Prolog-like syntax,
but currently the relations must be implemented by users in C++
or Python. More specifically, Relay’s type system uses an <em>ad hoc</em> solver
for type relations in which type relations are actually implemented as
C++ or Python functions that check whether the relation holds and
imperatively update any shape variables or incomplete types. In the current
implementation, the functions implementing relations should return <code class="code docutils literal notranslate"><span class="pre">False</span></code>
if the relation fails to hold and <code class="code docutils literal notranslate"><span class="pre">True</span></code> if the relation holds or if
there is not enough information to determine whether it holds or not.</p>
<p>The functions for all the relations are run as needed (if an input is updated)
until one of the following conditions holds:</p>
<ol class="arabic simple">
<li><p>All relations hold and no incomplete types remain (typechecking succeeds).</p></li>
<li><p>A relation fails to hold (a type error).</p></li>
<li><p>A fixpoint is reached where shape variables or incomplete types remain (either a type error or more type annotations may be needed).</p></li>
</ol>
<p>Presently all of the relations used in Relay are implemented in C++.
See the files in <code class="code docutils literal notranslate"><span class="pre">src/relay/op</span></code> for examples of relations implemented
in C++.</p>
<p>See <code class="xref py py-class docutils literal notranslate"><span class="pre">TypeRelation</span></code> for its definition and documentation.</p>
</div>
<div class="section" id="incomplete-type">
<h2>Incomplete Type<a class="headerlink" href="#incomplete-type" title="永久链接至标题">¶</a></h2>
<p>An incomplete type is a type or portion of a type that is not yet known.
This is only used during type inference. Any omitted type annotation is
replaced by an incomplete type, which will be replaced by another
type at a later point.</p>
<p>Incomplete types are known as “type variables” or “type holes” in the programming languages
literature. We use the name “incomplete type” in order to more clearly distinguish them from type
parameters: Type parameters must be bound to a function and are replaced with concrete type arguments (instantiated)
at call sites, whereas incomplete types may appear anywhere in the program and are filled in during type inference.</p>
<p>See <code class="xref py py-class docutils literal notranslate"><span class="pre">IncompleteType</span></code> for its definition and documentation.</p>
</div>
<div class="section" id="algebraic-data-types">
<span id="adt-typing"></span><h2>Algebraic Data Types<a class="headerlink" href="#algebraic-data-types" title="永久链接至标题">¶</a></h2>
<p><em>Note: ADTs are not currently supported in the text format.</em></p>
<p>Algebraic data types (ADTs) are described in more detail in
<a class="reference internal" href="relay_adt.html#adt-overview"><span class="std std-ref">their overview</span></a>; this section describes
their implementation in the type system.</p>
<p>An ADT is defined by a collection of named constructors,
each of which takes arguments of certain types.
An instance of an ADT is a container that stores the values
of the constructor arguments used to produce it as well as the
name of the constructor; the values can be retrieved by
deconstructing the instance by matching based on its constructor.
Hence, ADTs are sometimes called “tagged unions”: like a C-style
union, the contents of an instance for a given ADT may have
different types in certain cases, but the constructor serves as a
tag to indicate how to interpret the contents.</p>
<p>From the type system’s perspective, it is most pertinent that
ADTs can take type parameters (constructor arguments can be
type parameters, though ADT instances with different type
parameters must be treated as different types) and be
recursive (a constructor for an ADT can take an instance of
that ADT, thus an ADT like a tree or list can be inductively
built up). The representation of ADTs in the type system must
be able to accommodate these facts, as the below sections will detail.</p>
<div class="section" id="global-type-variable">
<h3>Global Type Variable<a class="headerlink" href="#global-type-variable" title="永久链接至标题">¶</a></h3>
<p>To represent ADTs compactly and easily allow for recursive ADT definitions,
an ADT definition is given a handle in the form of a global type variable
that uniquely identifies it. Each ADT definition is given a fresh global
type variable as a handle, so pointer equality can be used to distinguish
different ADT names.</p>
<p>For the purposes of Relay’s type system, ADTs are differentiated by name;
that means that if two ADTs have different handles, they will be
considered different types even if all their constructors are
structurally identical.</p>
<p>Recursion in an ADT definition thus follows just like recursion for a
global function: the constructor can simply reference the ADT handle
(global type variable) in its definition.</p>
<p>See <code class="xref py py-class docutils literal notranslate"><span class="pre">GlobalTypeVar</span></code> for its definition and documentation.</p>
</div>
<div class="section" id="definitions-type-data">
<h3>Definitions (Type Data)<a class="headerlink" href="#definitions-type-data" title="永久链接至标题">¶</a></h3>
<p>Besides a name, an ADT needs to store the constructors that are used
to define it and any type parameters used within them. These are
stored in the module, <a class="reference internal" href="relay_expr.html#module-description"><span class="std std-ref">analogous to global function definitions</span></a>.</p>
<p>While type-checking uses of ADTs, the type system sometimes must
index into the module using the ADT name to look up information
about constructors. For example, if a constructor is being pattern-matched
in a match expression clause, the type-checker must check the constructor’s
signature to ensure that any bound variables are being assigned the
correct types.</p>
<p>See <code class="xref py py-class docutils literal notranslate"><span class="pre">TypeData</span></code> for its definition and documentation.</p>
</div>
<div class="section" id="type-call">
<h3>Type Call<a class="headerlink" href="#type-call" title="永久链接至标题">¶</a></h3>
<p>Because an ADT definition can take type parameters, Relay’s type
system considers an ADT definition to be a <em>type-level function</em>
(in that the definition takes type parameters and returns the
type of an ADT instance with those type parameters). Thus, any
instance of an ADT is typed using a type call, which explicitly
lists the type parameters given to the ADT definition.</p>
<p>It is important to list the type parameters for an ADT instance,
as two ADT instances built using different constructors but the
same type parameters are of the <em>same type</em> while two ADT instances
with different type parameters should not be considered the same
type (e.g., a list of integers should not have the same type as
a list of pairs of floating point tensors).</p>
<p>The “function” in the type call is the ADT handle and there must
be one argument for each type parameter in the ADT definition. (An
ADT definition with no arguments means that any instance will have
no type arguments passed to the type call).</p>
<p>See <code class="xref py py-class docutils literal notranslate"><span class="pre">TypeCall</span></code> for its definition and documentation.</p>
</div>
<div class="section" id="example-list-adt">
<h3>Example: List ADT<a class="headerlink" href="#example-list-adt" title="永久链接至标题">¶</a></h3>
<p>This subsection uses the simple list ADT (included as a default
ADT in Relay) to illustrate the constructs described in the previous
sections. Its definition is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">Nil</span> <span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">List</span>
  <span class="n">Cons</span> <span class="p">:</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">a</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Thus, the global type variable <code class="code docutils literal notranslate"><span class="pre">List</span></code> is the handle for the ADT.
The type data for the list ADT in the module notes that
<code class="code docutils literal notranslate"><span class="pre">List</span></code> takes one type parameter and has two constructors,
<code class="code docutils literal notranslate"><span class="pre">Nil</span></code> (with signature <code class="code docutils literal notranslate"><span class="pre">fn&lt;a&gt;()</span> <span class="pre">-&gt;</span> <span class="pre">List[a]</span></code>)
and <code class="code docutils literal notranslate"><span class="pre">Cons</span></code> (with signature <code class="code docutils literal notranslate"><span class="pre">fn&lt;a&gt;(a,</span> <span class="pre">List[a])</span> <span class="pre">-&gt;</span> <span class="pre">List[a]</span></code>).
The recursive reference to <code class="code docutils literal notranslate"><span class="pre">List</span></code> in the <code class="code docutils literal notranslate"><span class="pre">Cons</span></code>
constructor is accomplished by using the global type
variable <code class="code docutils literal notranslate"><span class="pre">List</span></code> in the constructor definition.</p>
<p>Below two instances of lists with their types given, using type calls:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Cons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Nil</span><span class="p">()))</span> <span class="c1"># List[Tensor[(), int32]]</span>
<span class="n">Cons</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Cons</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">Nil</span><span class="p">()))</span> <span class="c1"># List[(Tensor[(), int32], Tensor[(), int32])]</span>
</pre></div>
</div>
<p>Note that <code class="code docutils literal notranslate"><span class="pre">Nil()</span></code> can be an instance of any list because it
does not take any arguments that use a type parameter. (Nevertheless,
for any <em>particular</em> instance of <code class="code docutils literal notranslate"><span class="pre">Nil()</span></code>, the type parameter must
be specified.)</p>
<p>Here are two lists that are rejected by the type system because
the type parameters do not match:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># attempting to put an integer on a list of int * int tuples</span>
<span class="n">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Cons</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Nil</span><span class="p">()))</span>
<span class="c1"># attempting to put a list of ints on a list of lists of int * int tuples</span>
<span class="n">Cons</span><span class="p">(</span><span class="n">Cons</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Cons</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Nil</span><span class="p">())),</span> <span class="n">Cons</span><span class="p">(</span><span class="n">Cons</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Cons</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">Nil</span><span class="p">())),</span> <span class="n">Nil</span><span class="p">()))</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">tvm-cn</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html">Installing TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributor Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../how_to/index.html">How To Guides</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dev/tutorial/index.html">Developer Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev/how_to/how_to.html">Developer How-To Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Architecture Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">Design and Architecture</a></li>
</ul>
<p class="caption"><span class="caption-text">Topic Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../topic/microtvm/index.html">microTVM: TVM on bare-metal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../topic/vta/index.html">VTA: Versatile Tensor Accelerator</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, HyperAI.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/reference/langref/relay_type.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>