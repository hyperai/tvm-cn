
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Convert Layout Pass &#8212; tvm-cn 1.0.0 文档</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="Benchmark Performance Log Format" href="benchmark.html" />
    <link rel="prev" title="Relay Operator Strategy" href="relay_op_strategy.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="convert-layout-pass">
<h1>Convert Layout Pass<a class="headerlink" href="#convert-layout-pass" title="永久链接至标题">¶</a></h1>
<p><strong>Author</strong>: <a class="reference external" href="https://github.com/anijain2305">Animesh Jain</a></p>
<div class="section" id="background">
<h2>1. Background<a class="headerlink" href="#background" title="永久链接至标题">¶</a></h2>
<p>Data layout format describes how the data is laid out in the memory. For example, Tensorflow framework default data layout for convolution operator is NHWC, i.e, the data is 4-dimensions and is laid out in row-major format with N being the first dimension and C being the last dimension. Data layout has a major role in model performance, significantly affecting spatial and temporal locality. For example, Intel x86 backend in TVM prefers layout as NCHWc where the C dimension is tiled in 2 dimensions to exploit data locality efficiently. Similarly, CUDA backend prefers the data layout to be in NCHW format.</p>
<p>Essentially, TVM has to deal with data layouts throughout the compiler toolchain - Framework parsers, Relay layout transformations, and TOPI schedules. As we move towards third-party codegen integration, which might have their own data layout restrictions, handling layouts at all levels in TVM toolchain is going to become even more challenging. Therefore, we developed a new Relay pass - <strong>ConvertLayout</strong> – to reduce some of the complications that arise due to layout handling.</p>
<p>If you directly want to understand the usage of ConvertLayout Pass, directly jump to Section 4 - Usage.</p>
</div>
<div class="section" id="motivation-and-overview">
<h2>2. Motivation and Overview<a class="headerlink" href="#motivation-and-overview" title="永久链接至标题">¶</a></h2>
<p>Let’s look at a simple scenario to understand the complications that arise due to different layouts - Suppose we want to compile a Tensorflow NHWC graph for an ARM edge device. But, suppose we currently support only NCHW schedules in TOPI for ARM. So, there is a mismatch between framework layout and TOPI-supported layout. One way to deal with this mismatch is to insert layout transforms before each and after convolution, such that resulting convolution has NCHW input data layout and can use TOPI schedules. However, this can lead to performance degradation because of the presence of too many layout transforms.</p>
<p>We encountered similar problems in other use cases as well</p>
<ul class="simple">
<li><p>No way to run TFLite graphs on Nvidia GPUs. TOPI has NCHW-only schedules for GPUs.</p></li>
<li><p>Ever-complicating logic in AlterOpLayout for convolution to support different pairs of layout transformations.</p></li>
<li><p>Sub-optimal performance for TF graphs due to extra layout transforms.</p></li>
<li><p>Complication in third-party codegen integrations like TensorRT that prefers data layout to be in one format.</p></li>
</ul>
<p>To solve these problems, we introduced <em>ConvertLayout</em> pass that sets up the infrastructure to change the data layout of the whole graph with minimal number of data layout transforms. In ideal cases, we will have only 2 layout transforms for data, one at the start and one at the end. An example to show the transformation is below</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Original graph - 2 convolutions in NHWC format.</span>
<span class="n">fn</span> <span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="n">float32</span><span class="p">],</span> <span class="o">%</span><span class="n">weight1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="n">float32</span><span class="p">],</span> <span class="o">%</span><span class="n">weight2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="n">float32</span><span class="p">])</span> <span class="p">{</span>
  <span class="o">%</span><span class="mi">0</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">,</span> <span class="o">%</span><span class="n">weight1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">data_layout</span><span class="o">=</span><span class="s2">&quot;NHWC&quot;</span><span class="p">,</span> <span class="n">kernel_layout</span><span class="o">=</span><span class="s2">&quot;HWIO&quot;</span><span class="p">);</span>
  <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span><span class="p">);</span>
  <span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">weight2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">data_layout</span><span class="o">=</span><span class="s2">&quot;NHWC&quot;</span><span class="p">,</span> <span class="n">kernel_layout</span><span class="o">=</span><span class="s2">&quot;HWIO&quot;</span><span class="p">);</span>
  <span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1"># After ConvertLayout - For data, there is a transform at the start and at the end.</span>
<span class="c1"># For weights, there are transforms to adapt to NCHW layout. These will be removed by FoldConstant pass.</span>
<span class="n">fn</span> <span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="n">float32</span><span class="p">],</span> <span class="o">%</span><span class="n">weight1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="n">float32</span><span class="p">],</span> <span class="o">%</span><span class="n">weight2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="n">float32</span><span class="p">])</span> <span class="p">{</span>
  <span class="o">%</span><span class="mi">0</span> <span class="o">=</span> <span class="n">layout_transform</span><span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">,</span> <span class="n">src_layout</span><span class="o">=</span><span class="s2">&quot;NHWC&quot;</span><span class="p">,</span> <span class="n">dst_layout</span><span class="o">=</span><span class="s2">&quot;NCHW&quot;</span><span class="p">)</span> <span class="o">/*</span> <span class="n">ty</span><span class="o">=</span><span class="n">Tensor</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">),</span> <span class="n">float32</span><span class="p">]</span> <span class="o">*/</span><span class="p">;</span>
  <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="n">layout_transform</span><span class="p">(</span><span class="o">%</span><span class="n">weight1</span><span class="p">,</span> <span class="n">src_layout</span><span class="o">=</span><span class="s2">&quot;HWIO&quot;</span><span class="p">,</span> <span class="n">dst_layout</span><span class="o">=</span><span class="s2">&quot;OIHW&quot;</span><span class="p">)</span> <span class="o">/*</span> <span class="n">ty</span><span class="o">=</span><span class="n">Tensor</span><span class="p">[(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">float32</span><span class="p">]</span> <span class="o">*/</span><span class="p">;</span>
  <span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="o">%</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/*</span> <span class="n">ty</span><span class="o">=</span><span class="n">Tensor</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">),</span> <span class="n">float32</span><span class="p">]</span> <span class="o">*/</span><span class="p">;</span>
  <span class="o">%</span><span class="mi">3</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span> <span class="o">/*</span> <span class="n">ty</span><span class="o">=</span><span class="n">Tensor</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">),</span> <span class="n">float32</span><span class="p">]</span> <span class="o">*/</span><span class="p">;</span>
  <span class="o">%</span><span class="mi">4</span> <span class="o">=</span> <span class="n">layout_transform</span><span class="p">(</span><span class="o">%</span><span class="n">weight2</span><span class="p">,</span> <span class="n">src_layout</span><span class="o">=</span><span class="s2">&quot;HWIO&quot;</span><span class="p">,</span> <span class="n">dst_layout</span><span class="o">=</span><span class="s2">&quot;OIHW&quot;</span><span class="p">)</span> <span class="o">/*</span> <span class="n">ty</span><span class="o">=</span><span class="n">Tensor</span><span class="p">[(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">float32</span><span class="p">]</span> <span class="o">*/</span><span class="p">;</span>
  <span class="o">%</span><span class="mi">5</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="o">%</span><span class="mi">3</span><span class="p">,</span> <span class="o">%</span><span class="mi">4</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">/*</span> <span class="n">ty</span><span class="o">=</span><span class="n">Tensor</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">),</span> <span class="n">float32</span><span class="p">]</span> <span class="o">*/</span><span class="p">;</span>
  <span class="o">%</span><span class="mi">6</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="o">%</span><span class="mi">5</span><span class="p">)</span> <span class="o">/*</span> <span class="n">ty</span><span class="o">=</span><span class="n">Tensor</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">),</span> <span class="n">float32</span><span class="p">]</span> <span class="o">*/</span><span class="p">;</span>
  <span class="n">layout_transform</span><span class="p">(</span><span class="o">%</span><span class="mi">6</span><span class="p">,</span> <span class="n">src_layout</span><span class="o">=</span><span class="s2">&quot;NCHW&quot;</span><span class="p">,</span> <span class="n">dst_layout</span><span class="o">=</span><span class="s2">&quot;NHWC&quot;</span><span class="p">)</span> <span class="o">/*</span> <span class="n">ty</span><span class="o">=</span><span class="n">Tensor</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="n">float32</span><span class="p">]</span> <span class="o">*/</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="design">
<h2>3. Design<a class="headerlink" href="#design" title="永久链接至标题">¶</a></h2>
<p>Before delving into ConvertLayout pass, let’s categorize the operators into 3 categories based on their sensitivity to data layouts. This categorization will be useful later to understand Convertlayout pass details.</p>
<ul class="simple">
<li><p><strong>Layout agnostic</strong> - Relu, pow etc. These operators are not affected, neither functionality nor performance, by data layouts.</p></li>
<li><p><strong>Lightly-layout sensitive</strong> - pad, concatenate, reduce ops like sum etc. These operators have some attributes that are functionally affected if we do a layout transformation before them. However, performance-wise, the difference is not significant. For these operators, it is beneficial to just adapt to the previous operator output data layout.</p></li>
<li><p><strong>Heavily-layout sensitive</strong> - Convolution, conv2d_transpose etc. These operators are heavily affected, both functionally and performance-wise, by data layouts. They also have data layout as the op attribute. Typically, it is beneficial to modify the input data layouts for these operators (if its not a performant data layout), while the rest of <em>layout agnostic</em> and <em>lightly-layout sensitive</em> operators adapt to the layout governed by the output of these <em>heavliy-layout sensitive</em> operators.</p></li>
</ul>
<p>Let us now look at two relevant Relay operator properties. Each relay operator has properties, like InferType, that can be defined by a TVM developer. Typically, a Relay pass traverses the graph operator-by-operator and reads these operator properties. For example, InferType pass looks at the InferType property of on operator, determines its output shape and type, and then passes it to the next operator InferType property. Similarly, in our context, we have 2 such properties - <em>FTVMConvertLayout</em> and <em>FInferCorrectLayout</em>. ConvertLayout pass traverses the graph and looks at these 2 properties along with an automatic layout transform insertion module to handle data layouts. So, the whole process can be broken down into 3 steps:</p>
<ul class="simple">
<li><p>Run FTVMConvertLayout property - This allows the developers to transform the original Relay expr into a new Relay expr with new layouts, allowing user-defined layout alteration. There is a python callback for developer’s ease. This is used only for heavily-layout sensitive operators.</p></li>
<li><p>Run FTVMInferCorretLayout property - We can view this as layout inference. It looks at the original input layout and the new input layouts, which are either coming from previous operator or from the FTVMConvertLayout modified expr (if it was used). This can be used by lightly-layout sensitive operators to adapt its attributes to new data layouts. Layout inference happens for each operator.</p></li>
<li><p>Automatic insertion of layout transforms - The previous step - layout inference - sets the new layout for the input exprs. If these layouts are different from the original layouts, then this component automatically inserts a layout transform. Therefore, a developer does not need to do anything for this component.</p></li>
</ul>
<p>These steps happen for each operator in sequence, where ConvertLayout pass keeps on passing the new layouts to the next operator properties, finally resulting in modifying the whole graph operator-by-operator. Now, let’s look at a couple of examples of how to define the two properties.</p>
<p><strong>FTVMConvertLayout - Python callback for layout alteration</strong> - This is used for <em>heavily-layout sensitive</em> operators. For example, one can return a new convolution operator with new data and kernel layout. The other 2 components will infer layout and insert layout transforms if needed. One example for convolution operator is as follows where we are converting to NCHW layout.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@reg</span><span class="o">.</span><span class="n">register_convert_op_layout</span><span class="p">(</span><span class="s2">&quot;nn.conv2d&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">convert_conv2d</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">tinfos</span><span class="p">,</span> <span class="n">desired_layouts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert Layout pass registration for conv2d op.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    attrs : tvm.attrs.Attrs</span>
<span class="sd">        Attributes of current convolution</span>
<span class="sd">    inputs : list of tvm.relay.Expr</span>
<span class="sd">        The args of the Relay expr to be legalized</span>
<span class="sd">    tinfos : list of types</span>
<span class="sd">        List of input and output types</span>
<span class="sd">    desired_layouts : list of layout strings</span>
<span class="sd">            List of layouts defining our desired</span>
<span class="sd">            layout for the data and kernel inputs respectively.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : tvm.relay.Expr</span>
<span class="sd">        The transformed expr</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">tvm</span> <span class="kn">import</span> <span class="n">relay</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">inputs</span>
    <span class="n">new_attrs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span>

    <span class="c1"># We expect 2 desired layouts to be specified, one for the data and one for the kernel.</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">desired_layouts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;A desired layout is expected for both of nn.conv2d&#39;s inputs&quot;</span>

    <span class="c1"># Use the first entry in desired layouts which specifies the data layout.</span>
    <span class="c1"># The expected ordering of layouts for this operator is defined by this function.</span>
    <span class="n">desired_data_layout</span><span class="p">,</span> <span class="n">desired_kernel_layout</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">desired_layouts</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">desired_data_layout</span> <span class="o">!=</span> <span class="s2">&quot;default&quot;</span><span class="p">,</span> <span class="s2">&quot;Data layout cannot be default&quot;</span>

    <span class="n">new_attrs</span><span class="p">[</span><span class="s1">&#39;data_layout&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">desired_data_layout</span>

    <span class="k">if</span> <span class="n">desired_data_layout</span> <span class="o">==</span> <span class="s1">&#39;NCHW&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">desired_kernel_layout</span> <span class="o">!=</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="n">new_attrs</span><span class="p">[</span><span class="s1">&#39;kernel_layout&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">desired_kernel_layout</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_attrs</span><span class="p">[</span><span class="s1">&#39;kernel_layout&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;OIHW&#39;</span>
        <span class="c1"># Actual insertion of layout transforms is taken care internally</span>
        <span class="c1"># by ConvertLayout pass.</span>
        <span class="k">return</span> <span class="n">relay</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">conv2d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="o">**</span><span class="n">new_attrs</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Layout </span><span class="si">%s</span><span class="s1"> is not yet supported&#39;</span> <span class="o">%</span> <span class="n">desired_data_layout</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>FInferCorrectLayout - Layout inference</strong> - Currently, this attribute is exposed only in C++. This function takes original input layouts and the new input layouts (passed from the previous operator or from the python callback for layout alteration), and infers the final data layouts. Layout inference is called for each operator. The usage might vary for different operator categories. For layout agnostic operators, we just want to return the new data layouts in this function. For lightly-layout and heavily-layout sensitive operators, we can change the operator attributes (like axis for concatenate, pad_width for pad) so that we can adapt to the new data layout, preventing insertion of layout transforms. Let’s look at a couple of examples to understand this better.</p>
<p>First example is for layout agnostic operators. These operators do not have any operator attributes that are affected by data layouts, so we just adapt to new layouts.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// For operator set its attributes like following</span>
<span class="c1">//          .set_attr&lt;FInferCorrectLayout&gt;(&quot;FInferCorrectLayout&quot;, ElemwiseArbitraryLayout);</span>

<span class="c1">// Take arbitrary input layouts and copy to outputs.</span>
<span class="kr">inline</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Layout</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ElemwiseArbitraryLayout</span><span class="p">(</span><span class="k">const</span> <span class="n">Attrs</span><span class="o">&amp;</span> <span class="n">attrs</span><span class="p">,</span>
                                                     <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Layout</span><span class="o">&gt;&amp;</span> <span class="n">new_in_layouts</span><span class="p">,</span>
                                                     <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Layout</span><span class="o">&gt;&amp;</span> <span class="n">old_in_layouts</span><span class="p">,</span>
                                                     <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">IndexExpr</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">old_in_shapes</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Layout</span> <span class="n">ret</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">new_in_layouts</span><span class="p">.</span><span class="n">defined</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">ICHECK_GE</span><span class="p">(</span><span class="n">new_in_layouts</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">new_in_layouts</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">old_in_layouts</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">old_in_layouts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">defined</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">old_in_layouts</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Layout</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">{</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Layout</span><span class="o">&gt;</span><span class="p">(</span><span class="n">old_in_layouts</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">ret</span><span class="p">),</span> <span class="p">{</span><span class="n">ret</span><span class="p">}};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Second example is for a lightly-layout sensitive operator - batch normalization. BatchNorm has an axis operator that has to change when we go from NHWC to NCHW data layout. (Similar handling also needs to be for heavily-layout sensitive operators)</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Layout</span><span class="o">&gt;&gt;</span> <span class="n">BatchNormInferCorrectLayout</span><span class="p">(</span><span class="k">const</span> <span class="n">Attrs</span><span class="o">&amp;</span> <span class="n">attrs</span><span class="p">,</span>
                                                 <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Layout</span><span class="o">&gt;&amp;</span> <span class="n">new_in_layouts</span><span class="p">,</span>
                                                 <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Layout</span><span class="o">&gt;&amp;</span> <span class="n">old_in_layouts</span><span class="p">,</span>
                                                 <span class="k">const</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">IndexExpr</span><span class="o">&gt;&gt;&amp;</span> <span class="n">old_in_shapes</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">BatchNormAttrs</span><span class="o">*</span> <span class="n">param</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">BatchNormAttrs</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">attrs</span><span class="p">.</span><span class="n">as</span><span class="o">&lt;</span><span class="n">BatchNormAttrs</span><span class="o">&gt;</span><span class="p">());</span>

  <span class="kt">size_t</span> <span class="n">axis</span> <span class="o">=</span>
      <span class="n">param</span><span class="o">-&gt;</span><span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">param</span><span class="o">-&gt;</span><span class="n">axis</span> <span class="o">+</span> <span class="n">old_in_shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">:</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">axis</span><span class="p">);</span>

  <span class="n">Layout</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">Layout</span><span class="o">::</span><span class="n">Undef</span><span class="p">();</span>

  <span class="c1">// For example, consider old_layout = NHWC, and new_layout = NCHW, and param-&gt;axis = 3</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">new_in_layouts</span><span class="p">.</span><span class="n">defined</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">old_in_layouts</span><span class="p">.</span><span class="n">defined</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Get the new C axis. Extract the dim in old layout. Find the index of that dim in next layout.</span>

    <span class="c1">// Following line gives bn_dim = C as old_layout = NHWC, axis = 3</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">bn_dim</span> <span class="o">=</span> <span class="n">old_in_layouts</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">axis</span><span class="p">];</span>

    <span class="c1">// The new_index is 1 because new_layout = NCHW and bn_dim is C</span>
    <span class="k">auto</span> <span class="n">new_index</span> <span class="o">=</span> <span class="n">new_in_layouts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">IndexOf</span><span class="p">(</span><span class="n">bn_dim</span><span class="p">);</span>

    <span class="c1">// We modify the layout-dependent attribute here - axis to 1.</span>
    <span class="n">param</span><span class="o">-&gt;</span><span class="n">axis</span> <span class="o">=</span> <span class="n">new_index</span><span class="p">;</span>

    <span class="c1">// Finally, we adapt to the new layout.</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">new_in_layouts</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old_in_layouts</span><span class="p">.</span><span class="n">defined</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">old_in_layouts</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">// In case both new and old layouts are undefined, then there is no need of a change.</span>
  <span class="c1">// ConvertLayout pass skips the automatic insertion of layout transforms in this case.</span>

  <span class="c1">// Following line is not important to tutorial. But, layout inference needs to define</span>
  <span class="c1">// the layout for all input and output data layouts. For batch norm, the other inputs</span>
  <span class="c1">// and outputs are vector having length of C dim in the input. So, we set the other</span>
  <span class="c1">// layouts as C. BN has 5 inputs, 3 outputs. The last 4 inputs and last 2 outputs</span>
  <span class="c1">// have &quot;C&quot; layout.</span>
  <span class="n">Layout</span> <span class="n">c_layout</span> <span class="o">=</span> <span class="n">Layout</span><span class="p">(</span><span class="s">&quot;C&quot;</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">Array</span><span class="o">&lt;</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Layout</span><span class="o">&gt;&gt;</span><span class="p">{{</span><span class="n">ret</span><span class="p">,</span> <span class="n">c_layout</span><span class="p">,</span> <span class="n">c_layout</span><span class="p">,</span> <span class="n">c_layout</span><span class="p">,</span> <span class="n">c_layout</span><span class="p">},</span>
                              <span class="p">{</span><span class="n">ret</span><span class="p">,</span> <span class="n">c_layout</span><span class="p">,</span> <span class="n">c_layout</span><span class="p">}};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="usage">
<h2>4. Usage<a class="headerlink" href="#usage" title="永久链接至标题">¶</a></h2>
<p id="convert-layout-usage">ConvertLayout pass is extremely easy to use. The pass is not a part of default relay.build pipeline. The intended usage is to call it between the framework-to-relay parser and relay.build module call.</p>
<p>In order to specify the layouts to convert to, we create a mapping of heavily-layout sensitive operators to a list of the desired layouts for that operator. The first example below specifies data layout, we allow the kernel layout to be automatically converted to one that is supported by TVM (for that particular data layout and operator). This is specified by the use of the “default” keyword. The second example shows how we could have also converted to a specific kernel layout of our choosing. It’s worth noting that the following examples will convert to the same layouts i.e. <cite>{‘nn.conv2d’: [‘NCHW’, ‘default’]} == {‘nn.conv2d’: [‘NCHW’, ‘OIHW’]}</cite></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># TFlite framework to Relay parser - Default layout is NHWC</span>
<span class="n">mod</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">relay</span><span class="o">.</span><span class="n">frontend</span><span class="o">.</span><span class="n">from_tflite</span><span class="p">(</span><span class="n">tflite_model</span><span class="p">,</span>
                                         <span class="n">shape_dict</span><span class="o">=</span><span class="n">shape_dict</span><span class="p">,</span>
                                         <span class="n">dtype_dict</span><span class="o">=</span><span class="n">dtype_dict</span><span class="p">)</span>

<span class="c1"># We assume our model&#39;s heavily-layout sensitive operators only consist of nn.conv2d</span>
<span class="n">desired_layouts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nn.conv2d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;NCHW&#39;</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">]}</span>

<span class="c1"># Convert the layout to NCHW</span>
<span class="c1"># RemoveUnunsedFunctions is used to clean up the graph.</span>
<span class="n">seq</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span><span class="n">relay</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">RemoveUnusedFunctions</span><span class="p">(),</span>
                                <span class="n">relay</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">ConvertLayout</span><span class="p">(</span><span class="n">desired_layouts</span><span class="p">)])</span>
<span class="k">with</span> <span class="n">tvm</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">PassContext</span><span class="p">(</span><span class="n">opt_level</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">mod</span> <span class="o">=</span> <span class="n">seq</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>

<span class="c1"># Call relay compilation</span>
<span class="k">with</span> <span class="n">relay</span><span class="o">.</span><span class="n">build_config</span><span class="p">(</span><span class="n">opt_level</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
     <span class="n">graph</span><span class="p">,</span> <span class="n">lib</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">relay</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">desired_layouts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nn.conv2d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;NCHW&#39;</span><span class="p">,</span> <span class="s1">&#39;OIHW&#39;</span><span class="p">]}</span>
<span class="k">pass</span> <span class="o">=</span> <span class="n">relay</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">ConvertLayout</span><span class="p">(</span><span class="n">desired_layouts</span><span class="p">)</span>
</pre></div>
</div>
<p>The ordering of the layouts is defined by the implementation of <cite>register_convert_op_layout(“OPNAME”)</cite>, you can refer to the docstring which should explicitly state the expected layout. In the examples above it’s [data_layout, kernel_layout].</p>
<p>Current implementation has support for almost all the operators commonly used in image classification models. However, if one encounters too many data layout transforms in the graph, it is highly likely that there is an operator whose layouts need special handling as described in Section 3. Some pull requests that can help in such a situation are</p>
<ul class="simple">
<li><p>Layout inference for <a class="reference external" href="https://github.com/apache/tvm/pull/4600">Batch Norm</a> - Batch normalization falls into the category of lightly-sensitive operator. The PR shows how to handle the layout inference for batch norm.</p></li>
<li><p>Python Callback for <a class="reference external" href="https://github.com/apache/tvm/pull/4335">Convolution</a>- For highly-sensitive operators, one might have to do python callback as well. The PR shows how to define a python callback function for Convolution operator.</p></li>
</ul>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">tvm-cn</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install/index.html">安装 TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">Contributor Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../how_to/index.html">How To Guides</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dev/tutorial/index.html">Developer Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/how_to/how_to.html">Developer How-To Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Architecture Guide</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Design and Architecture</a></li>
</ul>
<p class="caption"><span class="caption-text">Topic Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../topic/microtvm/index.html">microTVM: TVM on bare-metal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic/vta/index.html">VTA: Versatile Tensor Accelerator</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Design and Architecture</a><ul>
      <li>Previous: <a href="relay_op_strategy.html" title="上一章">Relay Operator Strategy</a></li>
      <li>Next: <a href="benchmark.html" title="下一章">Benchmark Performance Log Format</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, HyperAI.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/arch/convert_layout.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>