
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Design and Architecture &#8212; tvm-cn 1.0.0 文档</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="TVM Runtime System" href="runtime.html" />
    <link rel="prev" title="Python Target Parametrization" href="../dev/how_to/pytest_target_parametrization.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="design-and-architecture">
<h1>Design and Architecture<a class="headerlink" href="#design-and-architecture" title="永久链接至标题">¶</a></h1>
<p>This document is intended for developers who want to understand the
architecture of TVM and/or actively develop on the project.
This page is organized as follows:</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="#example-compilation-flow">Example Compilation Flow</a> gives an overview of the steps that TVM takes to turn a high level description of a model into a deployable module.
To get started, please read this section first.</p></li>
<li><p>The <a class="reference internal" href="#logical-architecture-components">Logical Architecture Components</a> section describes the logical components.
The sections after are specific guides focused on each logical component, organized
by the component’s name.</p></li>
<li><p>The <a class="reference internal" href="device_target_interactions.html#tvm-target-specific-overview"><span class="std std-ref">Device/Target Interactions</span></a>
page describes how TVM interacts with each supported physical device
and code-generation target.</p></li>
<li><p>Feel free to also check out the <a class="reference internal" href="../dev/how_to/how_to.html#dev-how-to"><span class="std std-ref">Developer How-To Guide</span></a> for useful development tips.</p></li>
</ul>
<p>This guide provides a few complementary views of the architecture.
First, we review a single end-to-end compilation flow and discuss the key data structures and the transformations.
This runtime-based view focuses on the interactions of each components when running the compiler.
Then we will review the logical modules of the codebase and their relationship. This part provides a static overarching view of the design.</p>
<div class="section" id="example-compilation-flow">
<h2>Example Compilation Flow<a class="headerlink" href="#example-compilation-flow" title="永久链接至标题">¶</a></h2>
<p>In this guide, we will study an example compilation flow in the compiler. The figure below shows the flow. At a high-level, it contains several steps:</p>
<ul class="simple">
<li><p>Import: The frontend component ingests a model into an IRModule, which contains a collection of functions that internally represent the model.</p></li>
<li><p>Transformation: The compiler transforms an IRModule to another functionally equivalent or approximately
equivalent(e.g. in the case of quantization) IRModule. Many of the transformations are target (backend) independent.
We also allow target to affect the configuration of the transformation pipeline.</p></li>
<li><p>Target Translation: The compiler translates(codegen) the IRModule to an executable format specified by the target.
The target translation result is encapsulated as a <cite>runtime.Module</cite> that can be exported, loaded, and executed on the target runtime environment.</p></li>
<li><p>Runtime Execution: the user loads back a <cite>runtime.Module</cite> and runs the compiled functions in the supported runtime environment.</p></li>
</ul>
<div class="figure align-center">
<a class="reference internal image-reference" href="https://raw.githubusercontent.com/tlc-pack/web-data/main/images/design/tvm_dyn_workflow.svg"><img alt="https://raw.githubusercontent.com/tlc-pack/web-data/main/images/design/tvm_dyn_workflow.svg" src="https://raw.githubusercontent.com/tlc-pack/web-data/main/images/design/tvm_dyn_workflow.svg" width="85%" /></a>
</div>
<div class="section" id="key-data-structures">
<h3>Key data structures<a class="headerlink" href="#key-data-structures" title="永久链接至标题">¶</a></h3>
<p>One of the best ways to design and understand a complex system is to identify the key data structures and APIs that
manipulate (transform) these data structures. Once we identified the key data structures, we can then breakdown a system into logical
components that either define a collection of key data structures or transformations among the data structures.</p>
<p><strong>IRModule</strong> is the primary data structure used across the entire stack. An IRModule (intermediate representation module)
contains a collection of functions. Currently, we support two primary variants of functions.</p>
<ul class="simple">
<li><p><strong>relay::Function</strong> is a high-level functional program representation. A relay.Function usually corresponds to an end-to-end model.
You can view a relay.Function as a computational graph with additional support for control-flow, recursion, and complex data structures.</p></li>
<li><p><strong>tir::PrimFunc</strong> is a low-level program representation that contains elements including loop-nest choices, multi-dimensional load/store,
threading, and vector/tensor instructions. It is usually used to represent an operator program that executes a (possibly-fused) layer in a model.</p></li>
</ul>
<p>During the compilation, a relay function may be lowered to multiple tir::PrimFunc functions and a top-level function that calls into
those tir::PrimFunc functions.</p>
</div>
<div class="section" id="transformations">
<h3>Transformations<a class="headerlink" href="#transformations" title="永久链接至标题">¶</a></h3>
<p>Now that we have covered the key data structures, let us talk about the transformations. Each transformation could serve one of the following purposes:</p>
<ul class="simple">
<li><p>optimization: transform a program to an equivalent, possibly more optimized version.</p></li>
<li><p>lowering: transform a program to a lower-level representation that is closer to the target.</p></li>
</ul>
<p><strong>relay/transform</strong> contains a collection of passes that optimize the model. The optimizations include common program
optimizations such as constant folding and dead-code elimination, and tensor-computation specific passes such as layout
transformation and scaling factor folding.</p>
<p>Near the end of the relay optimization pipeline, we will run a pass(FuseOps) to break the end-to-end function(e.g. MobileNet)
into sub-function(e.g. conv2d-relu) segments. We call these segments of functions.
This process helps us to divide the original problem into two sub-problems:</p>
<ul class="simple">
<li><p>Compilation and optimization for each sub-function.</p></li>
<li><p>Overall execution structure: we need to do a sequence of calls into the generated sub-functions to execute the whole model.</p></li>
</ul>
<p>We use the low-level tir phase to compile and optimize each sub-functions. For specific targets, we may also directly go to the target translation
phase and use external code generators.</p>
<p>There are a few different ways(in relay/backend) to handle the calls into the overall execution problem. For simple models with known shapes and no control flow, we can lower to a graph executor that stores the execution structure in a graph. We also support a virtual machine backend for dynamic executions. Finally, we plan to support ahead of time compilation that compiles the high-level execution structure into the executable and generated primitive functions. All of these execution modes are encapsulated by a unified <strong>runtime.Module</strong> interface, which we will discuss in the latter part of the guide.</p>
<p><strong>tir/transform</strong> contains transformation passes for TIR level functions. Many tir passes serve the purpose of lowering. For example, there are passes to flatten multi-dimensional access to one-dimensional pointer access, to expand the intrinsics into target-specific ones, and to decorate the function entry to meet the runtime calling convention. Of course, there are also optimizations passes, such as access index simplification and dead code elimination.</p>
<p>Many low-level optimizations can be handled in the target phase by the LLVM, CUDA C, and other target compilers. As a result, we leave low-level optimizations such as register allocation to the downstream compilers and only focus on optimizations that are not covered by them.</p>
</div>
<div class="section" id="search-space-and-learning-based-transformations">
<h3>Search-space and Learning-based Transformations<a class="headerlink" href="#search-space-and-learning-based-transformations" title="永久链接至标题">¶</a></h3>
<p>The transformation passes we described so far are deterministic and rule-based. One design goal of the TVM stack is to support high-performance code optimizations for different hardware platforms. To do so, we will need to investigate as many optimization choices as possible, including but not limited to, multi-dimensional tensor access, loop tiling behavior, special accelerator memory hierarchy, and threading.</p>
<p>It is hard to define a heuristic to make all of the choices. Instead, we will take a search and learning-based approach.
We first define a collection of actions we can take to transform a program. Example actions include loop transformations, inlining,
vectorization. We call these actions <strong>scheduling primitives</strong>. The collection of scheduling primitives defines a search space of possible
optimizations we can make to a program. The system then searches over different possible scheduling
sequence to pick the best scheduling combination.
The search procedure is usually guided by a machine learning algorithm.</p>
<p>We can record the best schedule sequence for an (possibly-fused) operator once the search is completed. The compiler can then just lookup the best
schedule sequence and apply it to the program. Notably, this schedule application phase is <strong>exactly like</strong> the rule-based transformations,
enabling us to share the same interface convention with tradition passes.</p>
<p>We use search based optimizations to handle the initial tir function generation problem. This part of the module is called AutoTVM(auto_scheduler).
We expect to expand the learning-based transformations to more areas as we continue to develop the TVM stack.</p>
</div>
<div class="section" id="target-translation">
<h3>Target Translation<a class="headerlink" href="#target-translation" title="永久链接至标题">¶</a></h3>
<p>The target translation phase transforms an IRModule to the corresponding target executable format.
For backends such as x86 and ARM, we use the LLVM IRBuilder to build in-memory LLVM IR.
We can also generate source-level languages such as CUDA C and OpenCL.
Finally, we support direct translations of a Relay function (sub-graph) to specific targets via external code generators.
It is important that the final code generation phase is as lightweight as possible. Vast majority of transformations
and lowering should be performed before the target translation phase.</p>
<p>We also provide a Target structure to specify the compilation target.
The transformations before the target translation phase can also be affected by the target — for example,
a target’s vector length would change the vectorization behavior.</p>
</div>
<div class="section" id="runtime-execution">
<h3>Runtime Execution<a class="headerlink" href="#runtime-execution" title="永久链接至标题">¶</a></h3>
<p>The main goal of TVM’s runtime is to provide a minimal API for loading and executing the compiled artifact in a language of their choice, including Python, C++, Rust, Go, Java, and JavaScript. The code snippet below shows such an example in Python:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tvm</span>
<span class="c1"># Example runtime execution program in python, with type annotated</span>
<span class="n">mod</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">Module</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="s2">&quot;compiled_artifact.so&quot;</span><span class="p">)</span>
<span class="n">arr</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">nd</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">tvm</span><span class="o">.</span><span class="n">cuda</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="n">fun</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">PackedFunc</span> <span class="o">=</span> <span class="n">mod</span><span class="p">[</span><span class="s2">&quot;addone&quot;</span><span class="p">]</span>
<span class="n">fun</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">tvm.runtime.Module</span></code> encapsulates the result of compilation. A runtime.Module contains a GetFunction method to obtain PackedFuncs by name.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">tvm.runtime.PackedFunc</span></code> is a type-erased function interface for both the generated functions. A runtime.PackedFunc can take arguments and return values with the
following types: POD types(int, float), string, runtime.PackedFunc, runtime.Module, runtime.NDArray, and other sub-classes of runtime.Object.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">tvm.runtime.Module</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">tvm.runtime.PackedFunc</span></code> are powerful mechanisms to modularize the runtime. For example, to get the above <cite>addone</cite> function on CUDA, we can use LLVM to generate the host-side code to compute the launching parameters(e.g. size of the thread groups) and then call into another PackedFunc from a CUDAModule that is backed by the CUDA driver API. The same mechanism can be used for OpenCL kernels.</p>
<p>The above example only deals with a simple <cite>addone</cite> function. The code snippet below gives an example of an end-to-end model execution using the same interface:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tvm</span>
<span class="c1"># Example runtime execution program in python, with types annotated</span>
<span class="n">factory</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">Module</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="s2">&quot;resnet18.so&quot;</span><span class="p">)</span>
<span class="c1"># Create a stateful graph execution module for resnet18 on cuda(0)</span>
<span class="n">gmod</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">Module</span> <span class="o">=</span> <span class="n">factory</span><span class="p">[</span><span class="s2">&quot;resnet18&quot;</span><span class="p">](</span><span class="n">tvm</span><span class="o">.</span><span class="n">cuda</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="n">data</span><span class="p">:</span> <span class="n">tvm</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">NDArray</span> <span class="o">=</span> <span class="n">get_input_data</span><span class="p">()</span>
<span class="c1"># set input</span>
<span class="n">gmod</span><span class="p">[</span><span class="s2">&quot;set_input&quot;</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="c1"># execute the model</span>
<span class="n">gmod</span><span class="p">[</span><span class="s2">&quot;run&quot;</span><span class="p">]()</span>
<span class="c1"># get the output</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">gmod</span><span class="p">[</span><span class="s2">&quot;get_output&quot;</span><span class="p">](</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
</pre></div>
</div>
<p>The main take away is that runtime.Module and runtime.PackedFunc are sufficient to encapsulate both operator level programs (such as addone), as well as the end-to-end models.</p>
</div>
<div class="section" id="summary-and-discussions">
<h3>Summary and Discussions<a class="headerlink" href="#summary-and-discussions" title="永久链接至标题">¶</a></h3>
<p>In summary, the key data structures in the compilation flows are:</p>
<ul class="simple">
<li><p>IRModule: contains relay.Function and tir.PrimFunc</p></li>
<li><p>runtime.Module: contains runtime.PackedFunc</p></li>
</ul>
<p>Most parts of the compilation are transformations among the key data structures.</p>
<ul class="simple">
<li><p>relay/transform and tir/transform are determinstic rule-based transformations</p></li>
<li><p>auto_scheduler and autotvm contains the search-based transformations</p></li>
</ul>
<p>Finally, the compilation flow example is only a typical use-case of the TVM stack.
We expose these key data structures and transformations to python and C++ APIs. As a result, you can use TVM just like the way you use numpy,
except that the data structure of interest changes from the numpy.ndarray to tvm.IRModule. Here are some example use-cases:</p>
<ul class="simple">
<li><p>Directly construct IRModule using the python API.</p></li>
<li><p>Compose a custom set of transformations(e.g. customize quantization).</p></li>
<li><p>Manipulate the IR directly using TVM’s python API.</p></li>
</ul>
</div>
</div>
<div class="section" id="logical-architecture-components">
<h2>Logical Architecture Components<a class="headerlink" href="#logical-architecture-components" title="永久链接至标题">¶</a></h2>
<div class="figure align-center" id="id1">
<a class="reference internal image-reference" href="https://raw.githubusercontent.com/tlc-pack/web-data/main/images/design/tvm_static_overview.svg"><img alt="https://raw.githubusercontent.com/tlc-pack/web-data/main/images/design/tvm_static_overview.svg" src="https://raw.githubusercontent.com/tlc-pack/web-data/main/images/design/tvm_static_overview.svg" width="85%" /></a>
<p class="caption"><span class="caption-text">TVM Architecture Diagram</span><a class="headerlink" href="#id1" title="永久链接至图片">¶</a></p>
</div>
<p>The above figure shows the major logical components in the project. Please read the following sections
for information about the components and their relations.</p>
</div>
<div class="section" id="tvm-support">
<h2>tvm/support<a class="headerlink" href="#tvm-support" title="永久链接至标题">¶</a></h2>
<p>The support module contains the most common utilities for the infrastructure, such as generic arena allocator, socket, and logging.</p>
</div>
<div class="section" id="tvm-runtime">
<h2>tvm/runtime<a class="headerlink" href="#tvm-runtime" title="永久链接至标题">¶</a></h2>
<p>The runtime serves as the foundation of the TVM stack. It provides the mechanism to load and execute compiled artifacts.
The runtime defines a stable standard set of C APIs to interface with frontend languages such as Python and Rust.</p>
<p><cite>runtime::Object</cite> is one of the primary data structures in TVM runtime besides the <cite>runtime::PackedFunc</cite>.
It is a reference-counted base class with a type index to support runtime type checking and downcasting.
The object system allows the developer to introduce new data structures to the runtime, such as Array, Map, and new IR data structures.</p>
<p>Besides deployment use-cases, the compiler itself also makes heavy use of TVM’s runtime mechanism.
All of the IR data structures are subclasses of <cite>runtime::Object</cite>, as a result, they can be directly accessed and manipulated from the Python frontend.
We use the PackedFunc mechanism to expose various APIs to the frontend.</p>
<p>Runtime support for different hardware backends are defined in subdirectories of runtime(e.g. runtime/opencl).
These hardware-specific runtime modules define APIs for device memory allocation and device function serialization.</p>
<p><cite>runtime/rpc</cite> implements an RPC support for PackedFunc. We can use the RPC mechanism to send a cross-compiled library to a remote
device and benchmark the execution performance. The rpc infrastructure enables data collection from a wide range of hardware backends
for learning-based optimizations.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="runtime.html">TVM Runtime System</a></li>
<li class="toctree-l1"><a class="reference internal" href="runtime.html#runtime-specific-information">Runtime-Specific Information</a></li>
</ul>
</div>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="debugger.html">Debugger</a></li>
<li class="toctree-l1"><a class="reference internal" href="virtual_machine.html">Putting the VM in TVM: The Relay Virtual Machine</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction_to_module_serialization.html">Introduction to Module Serialization</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_target_interactions.html">Device/Target Interactions</a></li>
</ul>
</div>
</div>
<div class="section" id="tvm-node">
<h2>tvm/node<a class="headerlink" href="#tvm-node" title="永久链接至标题">¶</a></h2>
<p>The node module adds additional features on top of the <cite>runtime::Object</cite> for IR data structures.
The main features include reflection, serialization, structural equivalence, and hashing.</p>
<p>Thanks to the node module, we can directly access any field of the TVM’s IRNode by their name in Python.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">tir</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;int32&quot;</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">tir</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="c1"># a and b are fields of a tir.Add node</span>
<span class="c1"># we can directly use the field name to access the IR structures</span>
<span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">a</span> <span class="o">==</span> <span class="n">x</span>
</pre></div>
</div>
<p>We can also serialize arbitrary IR node into a JSON format, and load them back.
The ability to save/store, and inspect an IR node provides a foundation for making the compiler more accessible.</p>
</div>
<div class="section" id="tvm-ir">
<h2>tvm/ir<a class="headerlink" href="#tvm-ir" title="永久链接至标题">¶</a></h2>
<p>The <cite>tvm/ir</cite> folder contains the unified data structure and interfaces across for all IR function variants.
The components in <cite>tvm/ir</cite> are shared by <cite>tvm/relay</cite> and <cite>tvm/tir</cite>, notable ones include</p>
<ul class="simple">
<li><p>IRModule</p></li>
<li><p>Type</p></li>
<li><p>PassContext and Pass</p></li>
<li><p>Op</p></li>
</ul>
<p>Different variants of functions(e.g. relay.Function and tir.PrimFunc) can co-exist in an IRModule.
While these variants may not have the same content representation, they use the same data structure to represent types.
As a consequence, we use the same data structure to represent function (type) signatures of these variants.
The unified type system allows one function variant to call another function
once we clearly define the calling convention. This opens doors for future cross-function-variant optimizations.</p>
<p>We also provide a unified PassContext for configuring the pass behavior, and common composite passes to execute a pass pipeline.
The following code snippet gives an example of PassContext configuration.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># configure the behavior of the tir.UnrollLoop pass</span>
<span class="k">with</span> <span class="n">tvm</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">PassContext</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;tir.UnrollLoop&quot;</span><span class="p">:</span> <span class="p">{</span> <span class="s2">&quot;auto_max_step&quot;</span><span class="p">:</span> <span class="mi">10</span> <span class="p">}}):</span>
    <span class="c1"># code affected by the pass context</span>
</pre></div>
</div>
<p>Op is the common class to represent all system-defined primitive operator/intrinsics.
Developers can register new Ops as well as their additional attributes(e.g. whether the Op is elementwise) to the system.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pass_infra.html">Pass Infrastructure</a></li>
</ul>
</div>
</div>
<div class="section" id="tvm-target">
<h2>tvm/target<a class="headerlink" href="#tvm-target" title="永久链接至标题">¶</a></h2>
<p>The target module contains all the code generators that translate an IRModule to a target runtime.Module.
It also provides a common <cite>Target</cite> class that describes the target.</p>
<p>The compilation pipeline can be customized according to the target by querying the attribute information
in the target and builtin information registered to each target id(cuda, opencl).</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="device_target_interactions.html">Device/Target Interactions</a></li>
</ul>
</div>
</div>
<div class="section" id="tvm-tir">
<h2>tvm/tir<a class="headerlink" href="#tvm-tir" title="永久链接至标题">¶</a></h2>
<p>TIR contains the definition of the low-level program representations. We use <cite>tir::PrimFunc</cite> to represent functions that can be transformed by TIR passes.
Besides the IR data structures, the tir module also defines a set of builtin intrinsics and their attributes via the common Op registry, as well as transformation passes in <cite>tir/transform</cite>.</p>
</div>
<div class="section" id="tvm-arith">
<h2>tvm/arith<a class="headerlink" href="#tvm-arith" title="永久链接至标题">¶</a></h2>
<p>This module is closely tied to the TIR. One of the key problems in the low-level code generation is the analysis of the indices’
arithmetic properties — the positiveness, variable bound, and the integer set that describes the iterator space. arith module provides
a collection of tools that do (primarily integer) analysis. A TIR pass can use these analyses to simplify and optimize the code.</p>
</div>
<div class="section" id="tvm-te">
<h2>tvm/te<a class="headerlink" href="#tvm-te" title="永久链接至标题">¶</a></h2>
<p>The name te stands for “tensor expression”. This is a domain-specific language module that allows us to construct <cite>tir::PrimFunc</cite> variants quickly by writing tensor expressions.
Importantly, a tensor expression itself is not a self-contained function that can be stored into IRModule. Instead, it is a fragment of IR that we can stitch together to build an IRModule.</p>
<p><cite>te/schedule</cite> provides a collection of scheduling primitives to control the function being generated. In the future, we might bring some of
these scheduling components to the a <cite>tir::PrimFunc</cite> itself.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="inferbound.html">InferBound Pass</a></li>
<li class="toctree-l1"><a class="reference internal" href="hybrid_script.html">Hybrid Frontend Developer Guide</a></li>
</ul>
</div>
</div>
<div class="section" id="tvm-topi">
<h2>tvm/topi<a class="headerlink" href="#tvm-topi" title="永久链接至标题">¶</a></h2>
<p>While possible to construct operators directly via TIR or tensor expressions (TE) for each use case it is tedious to do so.
<cite>topi</cite> (Tensor operator inventory) provides a set of pre-defined operators (in TE or TIR) defined by
numpy and found in common deep learning workloads. We also provide a collection of common schedule templates to obtain performant implementations across different target platforms.</p>
</div>
<div class="section" id="tvm-relay">
<h2>tvm/relay<a class="headerlink" href="#tvm-relay" title="永久链接至标题">¶</a></h2>
<p>Relay is the high-level functional IR used to represent full models. Various optimizations are defined in <cite>relay.transform</cite>. The Relay compiler defines multiple dialects,
and each dialect is designed to support specific styles of optimization. Notable ones include QNN(for importing pre-quantized models), VM(for lowering to dynamic virtual machine),
memory(for memory optimization).</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="relay_intro.html">Introduction to Relay IR</a></li>
<li class="toctree-l1"><a class="reference internal" href="relay_op_strategy.html">Relay Operator Strategy</a></li>
<li class="toctree-l1"><a class="reference internal" href="convert_layout.html">Convert Layout Pass</a></li>
</ul>
</div>
</div>
<div class="section" id="tvm-autotvm">
<h2>tvm/autotvm<a class="headerlink" href="#tvm-autotvm" title="永久链接至标题">¶</a></h2>
<p>AutoTVM and AutoScheduler are both components which automate search based program optimization. This is rapidly evolving and primarily consists of:</p>
<ul class="simple">
<li><p>Cost models and feature extraction.</p></li>
<li><p>A record format for storing program benchmark results for cost model construction.</p></li>
<li><p>A set of search policies over program transformations.</p></li>
</ul>
<p>Automated program optimization is still an active research field. As a result, we have attempted to modularize the design so that researchers may quickly modify a
component or apply their own algorithms via the Python bindings, and
customize the search and plugin their algorithms from the Python binding.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="benchmark.html">Benchmark Performance Log Format</a></li>
</ul>
</div>
</div>
<div class="section" id="frontends">
<h2>Frontends<a class="headerlink" href="#frontends" title="永久链接至标题">¶</a></h2>
<p>Frontends ingest models from different frameworks into the TVM stack.
<code class="xref py py-mod docutils literal notranslate"><span class="pre">tvm.relay.frontend</span></code> is the namespace for model ingestion APIs.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="frontend/tensorflow.html">TensorFlow Frontend</a></li>
</ul>
</div>
</div>
<div class="section" id="security">
<h2>Security<a class="headerlink" href="#security" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="security.html">Security Guide</a></li>
</ul>
</div>
</div>
<div class="section" id="microtvm">
<h2>microTVM<a class="headerlink" href="#microtvm" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="microtvm_design.html">microTVM Design Document</a></li>
<li class="toctree-l1"><a class="reference internal" href="microtvm_project_api.html">microTVM Project API</a></li>
<li class="toctree-l1"><a class="reference internal" href="model_library_format.html">Model Library Format</a></li>
</ul>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">tvm-cn</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install/index.html">Installing TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">Contributor Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../how_to/index.html">How To Guides</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dev/tutorial/index.html">Developer Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dev/how_to/how_to.html">Developer How-To Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Architecture Guide</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Design and Architecture</a></li>
</ul>
<p class="caption"><span class="caption-text">Topic Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../topic/microtvm/index.html">microTVM: TVM on bare-metal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../topic/vta/index.html">VTA: Versatile Tensor Accelerator</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="../dev/how_to/pytest_target_parametrization.html" title="上一章">Python Target Parametrization</a></li>
      <li>Next: <a href="runtime.html" title="下一章">TVM Runtime System</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, HyperAI.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/arch/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>