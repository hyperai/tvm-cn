
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Relay TensorRT Integration &#8212; tvm-cn 1.0.0 文档</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="Vitis AI Integration" href="vitis_ai.html" />
    <link rel="prev" title="Relay Arm® Compute Library Integration" href="arm_compute_lib.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="relay-tensorrt-integration">
<h1>Relay TensorRT Integration<a class="headerlink" href="#relay-tensorrt-integration" title="永久链接至标题">¶</a></h1>
<p><strong>Author</strong>: <a class="reference external" href="https://github.com/trevor-m">Trevor Morris</a></p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="永久链接至标题">¶</a></h2>
<p>NVIDIA TensorRT is a library for optimized deep learning inference. This integration will offload as
many operators as possible from Relay to TensorRT, providing a performance boost on NVIDIA GPUs
without the need to tune schedules.</p>
<p>This guide will demonstrate how to install TensorRT and build TVM with TensorRT BYOC and runtime
enabled. It will also provide example code to compile and run a ResNet-18 model using TensorRT and
how to configure the compilation and runtime settings. Finally, we document the supported operators
and how to extend the integration to support other operators.</p>
</div>
<div class="section" id="installing-tensorrt">
<h2>Installing TensorRT<a class="headerlink" href="#installing-tensorrt" title="永久链接至标题">¶</a></h2>
<p>In order to download TensorRT, you will need to create an NVIDIA Developer program account. Please
see NVIDIA’s documentation for more info:
<a class="reference external" href="https://docs.nvidia.com/deeplearning/tensorrt/install-guide/index.html">https://docs.nvidia.com/deeplearning/tensorrt/install-guide/index.html</a>. If you have a Jetson device
such as a TX1, TX2, Xavier, or Nano, TensorRT will already be installed on the device via the
JetPack SDK.</p>
<p>There are two methods to install TensorRT:</p>
<ul class="simple">
<li><p>System install via deb or rpm package.</p></li>
<li><p>Tar file installation.</p></li>
</ul>
<p>With the tar file installation method, you must provide the path of the extracted tar archive to
USE_TENSORRT_RUNTIME=/path/to/TensorRT. With the system install method,
USE_TENSORRT_RUNTIME=ON will automatically locate your installation.</p>
</div>
<div class="section" id="building-tvm-with-tensorrt-support">
<h2>Building TVM with TensorRT support<a class="headerlink" href="#building-tvm-with-tensorrt-support" title="永久链接至标题">¶</a></h2>
<p>There are two separate build flags for TensorRT integration in TVM. These flags also enable
cross-compilation: USE_TENSORRT_CODEGEN=ON will also you to build a module with TensorRT support on
a host machine, while USE_TENSORRT_RUNTIME=ON will enable the TVM runtime on an edge device to
execute the TensorRT module. You should enable both if you want to compile and also execute models
with the same TVM build.</p>
<ul class="simple">
<li><p>USE_TENSORRT_CODEGEN=ON/OFF - This flag will enable compiling a TensorRT module, which does not require any
TensorRT library.</p></li>
<li><p>USE_TENSORRT_RUNTIME=ON/OFF/path-to-TensorRT - This flag will enable the TensorRT runtime module.
This will build TVM against the installed TensorRT library.</p></li>
</ul>
<p>Example setting in config.cmake file:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span><span class="p">(</span><span class="s">USE_TENSORRT_CODEGEN</span> <span class="s">ON</span><span class="p">)</span>
<span class="nb">set</span><span class="p">(</span><span class="s">USE_TENSORRT_RUNTIME</span> <span class="s">/home/ubuntu/TensorRT-7.0.0.11</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="build-and-deploy-resnet-18-with-tensorrt">
<h2>Build and Deploy ResNet-18 with TensorRT<a class="headerlink" href="#build-and-deploy-resnet-18-with-tensorrt" title="永久链接至标题">¶</a></h2>
<p>Create a Relay graph from a MXNet ResNet-18 model.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tvm</span>
<span class="kn">from</span> <span class="nn">tvm</span> <span class="kn">import</span> <span class="n">relay</span>
<span class="kn">import</span> <span class="nn">mxnet</span>
<span class="kn">from</span> <span class="nn">mxnet.gluon.model_zoo.vision</span> <span class="kn">import</span> <span class="n">get_model</span>

<span class="n">dtype</span> <span class="o">=</span> <span class="s2">&quot;float32&quot;</span>
<span class="n">input_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">)</span>
<span class="n">block</span> <span class="o">=</span> <span class="n">get_model</span><span class="p">(</span><span class="s1">&#39;resnet18_v1&#39;</span><span class="p">,</span> <span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">mod</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">relay</span><span class="o">.</span><span class="n">frontend</span><span class="o">.</span><span class="n">from_mxnet</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">input_shape</span><span class="p">},</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
<p>Annotate and partition the graph for TensorRT. All ops which are supported by the TensorRT
integration will be marked and offloaded to TensorRT. The rest of the ops will go through the
regular TVM CUDA compilation and code generation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tvm.relay.op.contrib.tensorrt</span> <span class="kn">import</span> <span class="n">partition_for_tensorrt</span>
<span class="n">mod</span><span class="p">,</span> <span class="n">config</span> <span class="o">=</span> <span class="n">partition_for_tensorrt</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<p>Build the Relay graph, using the new module and config returned by partition_for_tensorrt. The
target must always be a cuda target. <code class="docutils literal notranslate"><span class="pre">partition_for_tensorrt</span></code> will automatically fill out the
required values in the config, so there is no need to modify it - just pass it along to the
PassContext so the values can be read during compilation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">target</span> <span class="o">=</span> <span class="s2">&quot;cuda&quot;</span>
<span class="k">with</span> <span class="n">tvm</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">PassContext</span><span class="p">(</span><span class="n">opt_level</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;relay.ext.tensorrt.options&#39;</span><span class="p">:</span> <span class="n">config</span><span class="p">}):</span>
    <span class="n">lib</span> <span class="o">=</span> <span class="n">relay</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<p>Export the module.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lib</span><span class="o">.</span><span class="n">export_library</span><span class="p">(</span><span class="s1">&#39;compiled.so&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Load module and run inference on the target machine, which must be built with
<code class="docutils literal notranslate"><span class="pre">USE_TENSORRT_RUNTIME</span></code> enabled. The first run will take longer because the TensorRT engine will
have to be built.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">cuda</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">loaded_lib</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="s1">&#39;compiled.so&#39;</span><span class="p">)</span>
<span class="n">gen_module</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">contrib</span><span class="o">.</span><span class="n">graph_executor</span><span class="o">.</span><span class="n">GraphModule</span><span class="p">(</span><span class="n">loaded_lib</span><span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">](</span><span class="n">dev</span><span class="p">))</span>
<span class="n">input_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">input_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">gen_module</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">input_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="partitioning-and-compilation-settings">
<h2>Partitioning and Compilation Settings<a class="headerlink" href="#partitioning-and-compilation-settings" title="永久链接至标题">¶</a></h2>
<p>There are some options which can be configured in <code class="docutils literal notranslate"><span class="pre">partition_for_tensorrt</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">version</span></code> - TensorRT version to target as tuple of (major, minor, patch). If TVM is compiled
with USE_TENSORRT_RUNTIME=ON, the linked TensorRT version will be used instead. The version
will affect which ops can be partitioned to TensorRT.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">use_implicit_batch</span></code> - Use TensorRT implicit batch mode (default true). Setting to false will
enable explicit batch mode which will widen supported operators to include those which modify the
batch dimension, but may reduce performance for some models.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">remove_no_mac_subgraphs</span></code> - A heuristic to improve performance. Removes subgraphs which have
been partitioned for TensorRT if they do not have any multiply-accumulate operations. The removed
subgraphs will go through TVM’s standard compilation instead.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_workspace_size</span></code> - How many bytes of workspace size to allow each subgraph to use for
TensorRT engine creation. See TensorRT documentation for more info. Can be overriden at runtime.</p></li>
</ul>
</div>
<div class="section" id="runtime-settings">
<h2>Runtime Settings<a class="headerlink" href="#runtime-settings" title="永久链接至标题">¶</a></h2>
<p>There are some additional options which can be configured at runtime using environment variables.</p>
<ul class="simple">
<li><p>Automatic FP16 Conversion - Environment variable <code class="docutils literal notranslate"><span class="pre">TVM_TENSORRT_USE_FP16=1</span></code> can be set to
automatically convert the TensorRT components of your model to 16-bit floating point precision.
This can greatly increase performance, but may cause some slight loss in the model accuracy.</p></li>
<li><p>Caching TensorRT Engines - During the first inference, the runtime will invoke the TensorRT API
to build an engine. This can be time consuming, so you can set <code class="docutils literal notranslate"><span class="pre">TVM_TENSORRT_CACHE_DIR</span></code> to
point to a directory to save these built engines to on the disk. The next time you load the model
and give it the same directory, the runtime will load the already built engines to avoid the long
warmup time. A unique directory is required for each model.</p></li>
<li><p>TensorRT has a paramter to configure the maximum amount of scratch space that each layer in the
model can use. It is generally best to use the highest value which does not cause you to run out
of memory. You can use <code class="docutils literal notranslate"><span class="pre">TVM_TENSORRT_MAX_WORKSPACE_SIZE</span></code> to override this by specifying the
workspace size in bytes you would like to use.</p></li>
<li><p>For models which contain a dynamic batch dimension, the varaible <code class="docutils literal notranslate"><span class="pre">TVM_TENSORRT_MULTI_ENGINE</span></code>
can be used to determine how TensorRT engines will be created at runtime. The default mode,
<code class="docutils literal notranslate"><span class="pre">TVM_TENSORRT_MULTI_ENGINE=0</span></code>, will maintain only one engine in memory at a time. If an input
is encountered with a higher batch size, the engine will be rebuilt with the new max_batch_size
setting. That engine will be compatible with all batch sizes from 1 to max_batch_size. This mode
reduces the amount of memory used at runtime. The second mode, <code class="docutils literal notranslate"><span class="pre">TVM_TENSORRT_MULTI_ENGINE=1</span></code>
will build a unique TensorRT engine which is optimized for each batch size that is encountered.
This will give greater performance, but will consume more memory.</p></li>
</ul>
</div>
<div class="section" id="operator-support">
<h2>Operator support<a class="headerlink" href="#operator-support" title="永久链接至标题">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Relay Node</p></th>
<th class="head"><p>Remarks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>nn.relu</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>sigmoid</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>tanh</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>nn.batch_norm</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>nn.layer_norm</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>nn.softmax</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>nn.conv1d</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>nn.conv2d</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>nn.dense</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>nn.bias_add</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>add</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>subtract</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>multiply</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>divide</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>power</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>maximum</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>minimum</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>nn.max_pool2d</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>nn.avg_pool2d</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>nn.global_max_pool2d</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>nn.global_avg_pool2d</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>exp</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>log</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>sqrt</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>abs</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>negative</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>nn.batch_flatten</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>expand_dims</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>squeeze</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>concatenate</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>nn.conv2d_transpose</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>transpose</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>layout_transform</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>reshape</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>nn.pad</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>sum</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>prod</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>max</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>min</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>mean</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>nn.adaptive_max_pool2d</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>nn.adaptive_avg_pool2d</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p>nn.batch_matmul</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>clip</p></td>
<td><p>Requires TensorRT 5.1.5 or greater</p></td>
</tr>
<tr class="row-even"><td><p>nn.leaky_relu</p></td>
<td><p>Requires TensorRT 5.1.5 or greater</p></td>
</tr>
<tr class="row-odd"><td><p>sin</p></td>
<td><p>Requires TensorRT 5.1.5 or greater</p></td>
</tr>
<tr class="row-even"><td><p>cos</p></td>
<td><p>Requires TensorRT 5.1.5 or greater</p></td>
</tr>
<tr class="row-odd"><td><p>atan</p></td>
<td><p>Requires TensorRT 5.1.5 or greater</p></td>
</tr>
<tr class="row-even"><td><p>ceil</p></td>
<td><p>Requires TensorRT 5.1.5 or greater</p></td>
</tr>
<tr class="row-odd"><td><p>floor</p></td>
<td><p>Requires TensorRT 5.1.5 or greater</p></td>
</tr>
<tr class="row-even"><td><p>split</p></td>
<td><p>Requires TensorRT 5.1.5 or greater</p></td>
</tr>
<tr class="row-odd"><td><p>strided_slice</p></td>
<td><p>Requires TensorRT 5.1.5 or greater</p></td>
</tr>
<tr class="row-even"><td><p>nn.conv3d</p></td>
<td><p>Requires TensorRT 6.0.1 or greater</p></td>
</tr>
<tr class="row-odd"><td><p>nn.max_pool3d</p></td>
<td><p>Requires TensorRT 6.0.1 or greater</p></td>
</tr>
<tr class="row-even"><td><p>nn.avg_pool3d</p></td>
<td><p>Requires TensorRT 6.0.1 or greater</p></td>
</tr>
<tr class="row-odd"><td><p>nn.conv3d_transpose</p></td>
<td><p>Requires TensorRT 6.0.1 or greater</p></td>
</tr>
<tr class="row-even"><td><p>erf</p></td>
<td><p>Requires TensorRT 7.0.0 or greater</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="adding-a-new-operator">
<h2>Adding a new operator<a class="headerlink" href="#adding-a-new-operator" title="永久链接至标题">¶</a></h2>
<p>To add support for a new operator, there are a series of files we need to make changes to:</p>
<ul class="simple">
<li><p><cite>src/runtime/contrib/tensorrt/tensorrt_ops.cc</cite> Create a new op converter class which
implements the <code class="docutils literal notranslate"><span class="pre">TensorRTOpConverter</span></code> interface. You must implement the constructor to specify how
many inputs there are and whether they are tensors or weights. You must also implement the
<code class="docutils literal notranslate"><span class="pre">Convert</span></code> method to perform the conversion. This is done by using the inputs, attributes, and
network from params to add the new TensorRT layers and push the layer outputs. You can use the
existing converters as an example. Finally, register your new op conventer in the
<code class="docutils literal notranslate"><span class="pre">GetOpConverters()</span></code> map.</p></li>
<li><p><cite>python/relay/op/contrib/tensorrt.py</cite> This file contains the annotation rules for TensorRT. These
determine which operators and their attributes that are supported. You must register an annotation
function for the relay operator and specify which attributes are supported by your converter, by
checking the attributes are returning true or false.</p></li>
<li><p><cite>tests/python/contrib/test_tensorrt.py</cite> Add unit tests for the given operator.</p></li>
</ul>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">tvm-cn</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html">Installing TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributor Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">How To Guides</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dev/tutorial/index.html">Developer Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev/how_to/how_to.html">Developer How-To Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Architecture Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">Design and Architecture</a></li>
</ul>
<p class="caption"><span class="caption-text">Topic Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../topic/microtvm/index.html">microTVM: TVM on bare-metal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../topic/vta/index.html">VTA: Versatile Tensor Accelerator</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">How To Guides</a><ul>
  <li><a href="index.html">Deploy Models and Integrate TVM</a><ul>
      <li>Previous: <a href="arm_compute_lib.html" title="上一章">Relay Arm<sup>®</sup> Compute Library Integration</a></li>
      <li>Next: <a href="vitis_ai.html" title="下一章">Vitis AI Integration</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, HyperAI.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/how_to/deploy/tensorrt.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>