
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Relay Arm® Compute Library Integration &#8212; tvm-cn 1.0.0 文档</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <script src="../../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="Relay TensorRT Integration" href="tensorrt.html" />
    <link rel="prev" title="HLS Backend Example" href="hls.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="relay-arm-compute-library-integration">
<h1>Relay Arm<sup>®</sup> Compute Library Integration<a class="headerlink" href="#relay-arm-compute-library-integration" title="永久链接至标题">¶</a></h1>
<p><strong>Author</strong>: <a class="reference external" href="https://github.com/lhutton1">Luke Hutton</a></p>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="永久链接至标题">¶</a></h2>
<p>Arm Compute Library (ACL) is an open source project that provides accelerated kernels for Arm CPU’s
and GPU’s. Currently the integration offloads operators to ACL to use hand-crafted assembler
routines in the library. By offloading select operators from a relay graph to ACL we can achieve
a performance boost on such devices.</p>
</div>
<div class="section" id="installing-arm-compute-library">
<h2>Installing Arm Compute Library<a class="headerlink" href="#installing-arm-compute-library" title="永久链接至标题">¶</a></h2>
<p>Before installing Arm Compute Library, it is important to know what architecture to build for. One way
to determine this is to use <cite>lscpu</cite> and look for the “Model name” of the CPU. You can then use this to
determine the architecture by looking online.</p>
<p>TVM only supports a single version of ACL, currently this is v21.08, there are two recommended ways to build and install
the required libraries:</p>
<ul>
<li><p>Use the script located at <cite>docker/install/ubuntu_download_arm_compute_lib_binaries.sh</cite>. You can use this
script for downloading ACL binaries for the architecture and extensions specified in <cite>target_lib</cite>, these
will be installed to the location denoted by <cite>install_path</cite>.</p></li>
<li><p>Alternatively, you can download the pre-built binaries from:
<a class="reference external" href="https://github.com/ARM-software/ComputeLibrary/releases">https://github.com/ARM-software/ComputeLibrary/releases</a>. When using this package, you will need to
select the binaries for the architecture and extensions you require, then make sure they are visible
to CMake:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span> &lt;acl-prebuilt-package&gt;/lib
mv ./&lt;architecture-and-extensions-required&gt;/* .
</pre></div>
</div>
</li>
</ul>
<p>In both cases you will need to set USE_ARM_COMPUTE_LIB_GRAPH_EXECUTOR to the path where the ACL package
is located. CMake will look in /path-to-acl/ along with /path-to-acl/lib and /path-to-acl/build for the
required binaries. See the section below for more information on how to use these configuration options.</p>
</div>
<div class="section" id="building-with-acl-support">
<h2>Building with ACL support<a class="headerlink" href="#building-with-acl-support" title="永久链接至标题">¶</a></h2>
<p>The current implementation has two separate build options in CMake. The reason for this split is
because ACL cannot be used on an x86 machine. However, we still want to be able compile an ACL
runtime module on an x86 machine.</p>
<ul class="simple">
<li><p>USE_ARM_COMPUTE_LIB=ON/OFF - Enabling this flag will add support for compiling an ACL runtime module.</p></li>
<li><p>USE_ARM_COMPUTE_LIB_GRAPH_EXECUTOR=ON/OFF/path-to-acl - Enabling this flag will allow the graph executor to
compute the ACL offloaded functions.</p></li>
</ul>
<p>These flags can be used in different scenarios depending on your setup. For example, if you want
to compile an ACL module on an x86 machine and then run the module on a remote Arm device via RPC, you will
need to use USE_ARM_COMPUTE_LIB=ON on the x86 machine and USE_ARM_COMPUTE_LIB_GRAPH_EXECUTOR=ON on the remote
AArch64 device.</p>
<p>By default both options are set to OFF. Using USE_ARM_COMPUTE_LIB_GRAPH_EXECUTOR=ON will mean that ACL
binaries are searched for by CMake in the default locations
(see <a class="reference external" href="https://cmake.org/cmake/help/v3.4/command/find_library.html">https://cmake.org/cmake/help/v3.4/command/find_library.html</a>). In addition to this,
/path-to-tvm-project/acl/ will also be searched. It is likely that you will need to set your own path to
locate ACL. This can be done by specifying a path in the place of ON.</p>
<p>These flags should be set in your config.cmake file. For example:</p>
<div class="highlight-cmake notranslate"><div class="highlight"><pre><span></span><span class="nb">set</span><span class="p">(</span><span class="s">USE_ARM_COMPUTE_LIB</span> <span class="s">ON</span><span class="p">)</span>
<span class="nb">set</span><span class="p">(</span><span class="s">USE_ARM_COMPUTE_LIB_GRAPH_EXECUTOR</span> <span class="s">/path/to/acl</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="永久链接至标题">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>This section may not stay up-to-date with changes to the API.</p>
</div>
<p>Create a relay graph. This may be a single operator or a whole graph. The intention is that any
relay graph can be input. The ACL integration will only pick supported operators to be offloaded
whilst the rest will be computed via TVM. (For this example we will use a single
max_pool2d operator).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tvm</span>
<span class="kn">from</span> <span class="nn">tvm</span> <span class="kn">import</span> <span class="n">relay</span>

<span class="n">data_type</span> <span class="o">=</span> <span class="s2">&quot;float32&quot;</span>
<span class="n">data_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>
<span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">pool_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">layout</span> <span class="o">=</span> <span class="s2">&quot;NHWC&quot;</span>
<span class="n">output_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">relay</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">data_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data_type</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">relay</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">max_pool2d</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pool_size</span><span class="o">=</span><span class="n">pool_size</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">)</span>
<span class="n">module</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">IRModule</span><span class="o">.</span><span class="n">from_expr</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
<p>Annotate and partition the graph for ACL.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tvm.relay.op.contrib.arm_compute_lib</span> <span class="kn">import</span> <span class="n">partition_for_arm_compute_lib</span>
<span class="n">module</span> <span class="o">=</span> <span class="n">partition_for_arm_compute_lib</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
</pre></div>
</div>
<p>Build the Relay graph.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">target</span> <span class="o">=</span> <span class="s2">&quot;llvm -mtriple=aarch64-linux-gnu -mattr=+neon&quot;</span>
<span class="k">with</span> <span class="n">tvm</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">PassContext</span><span class="p">(</span><span class="n">opt_level</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">disabled_pass</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;AlterOpLayout&quot;</span><span class="p">]):</span>
    <span class="n">lib</span> <span class="o">=</span> <span class="n">relay</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
</pre></div>
</div>
<p>Export the module.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lib_path</span> <span class="o">=</span> <span class="s1">&#39;~/lib_acl.so&#39;</span>
<span class="n">cross_compile</span> <span class="o">=</span> <span class="s1">&#39;aarch64-linux-gnu-c++&#39;</span>
<span class="n">lib</span><span class="o">.</span><span class="n">export_library</span><span class="p">(</span><span class="n">lib_path</span><span class="p">,</span> <span class="n">cc</span><span class="o">=</span><span class="n">cross_compile</span><span class="p">)</span>
</pre></div>
</div>
<p>Run Inference. This must be on an Arm device. If compiling on x86 device and
running on AArch64, consider using the RPC mechanism. <span class="xref std std-ref">Tutorials for using
the RPC mechanism</span></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dev</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">cpu</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">loaded_lib</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">load_module</span><span class="p">(</span><span class="s1">&#39;lib_acl.so&#39;</span><span class="p">)</span>
<span class="n">gen_module</span> <span class="o">=</span> <span class="n">tvm</span><span class="o">.</span><span class="n">contrib</span><span class="o">.</span><span class="n">graph_executor</span><span class="o">.</span><span class="n">GraphModule</span><span class="p">(</span><span class="n">loaded_lib</span><span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">](</span><span class="n">dev</span><span class="p">))</span>
<span class="n">d_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data_shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data_type</span><span class="p">)</span>
<span class="n">map_inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">d_data</span><span class="p">}</span>
<span class="n">gen_module</span><span class="o">.</span><span class="n">set_input</span><span class="p">(</span><span class="o">**</span><span class="n">map_inputs</span><span class="p">)</span>
<span class="n">gen_module</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="more-examples">
<h2>More examples<a class="headerlink" href="#more-examples" title="永久链接至标题">¶</a></h2>
<p>The example above only shows a basic example of how ACL can be used for offloading a single
Maxpool2D. If you would like to see more examples for each implemented operator and for
networks refer to the tests: <cite>tests/python/contrib/test_arm_compute_lib</cite>. Here you can modify
<cite>test_config.json</cite> to configure how a remote device is created in <cite>infrastructure.py</cite> and,
as a result, how runtime tests will be run.</p>
<p>An example configuration for <cite>test_config.json</cite>:</p>
<ul class="simple">
<li><p>connection_type - The type of RPC connection. Options: local, tracker, remote.</p></li>
<li><p>host - The host device to connect to.</p></li>
<li><p>port - The port to use when connecting.</p></li>
<li><p>target - The target to use for compilation.</p></li>
<li><p>device_key - The device key when connecting via a tracker.</p></li>
<li><p>cross_compile - Path to cross compiler when connecting from a non-arm platform e.g. aarch64-linux-gnu-g++.</p></li>
</ul>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;connection_type&quot;</span><span class="p">:</span> <span class="s2">&quot;local&quot;</span><span class="p">,</span>
  <span class="nt">&quot;host&quot;</span><span class="p">:</span> <span class="s2">&quot;127.0.0.1&quot;</span><span class="p">,</span>
  <span class="nt">&quot;port&quot;</span><span class="p">:</span> <span class="mi">9090</span><span class="p">,</span>
  <span class="nt">&quot;target&quot;</span><span class="p">:</span> <span class="s2">&quot;llvm -mtriple=aarch64-linux-gnu -mattr=+neon&quot;</span><span class="p">,</span>
  <span class="nt">&quot;device_key&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
  <span class="nt">&quot;cross_compile&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="operator-support">
<h2>Operator support<a class="headerlink" href="#operator-support" title="永久链接至标题">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Relay Node</p></th>
<th class="head"><p>Remarks</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>nn.conv2d</p></td>
<td><dl class="simple">
<dt>fp32:</dt><dd><p>Simple: nn.conv2d
Composite: nn.pad?, nn.conv2d, nn.bias_add?, nn.relu?</p>
</dd>
</dl>
<p>Normal and depth-wise (when kernel is 3x3 or 5x5 and strides are 1x1
or 2x2) convolution supported. Grouped convolution is not supported.</p>
</td>
</tr>
<tr class="row-odd"><td><p>qnn.conv2d</p></td>
<td><dl class="simple">
<dt>uint8:</dt><dd><p>Composite: nn.pad?, nn.conv2d, nn.bias_add?, nn.relu?, qnn.requantize</p>
</dd>
</dl>
<p>Normal and depth-wise (when kernel is 3x3 or 5x5 and strides are 1x1
or 2x2) convolution supported. Grouped convolution is not supported.</p>
</td>
</tr>
<tr class="row-even"><td><p>nn.dense</p></td>
<td><dl class="simple">
<dt>fp32:</dt><dd><p>Simple: nn.dense
Composite: nn.dense, nn.bias_add?</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>qnn.dense</p></td>
<td><dl class="simple">
<dt>uint8:</dt><dd><p>Composite: qnn.dense, nn.bias_add?, qnn.requantize</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>nn.max_pool2d</p></td>
<td><p>fp32, uint8</p></td>
</tr>
<tr class="row-odd"><td><p>nn.global_max_pool2d</p></td>
<td><p>fp32, uint8</p></td>
</tr>
<tr class="row-even"><td><p>nn.avg_pool2d</p></td>
<td><dl class="simple">
<dt>fp32:</dt><dd><p>Simple: nn.avg_pool2d</p>
</dd>
<dt>uint8:</dt><dd><p>Composite: cast(int32), nn.avg_pool2d, cast(uint8)</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>nn.global_avg_pool2d</p></td>
<td><dl class="simple">
<dt>fp32:</dt><dd><p>Simple: nn.global_avg_pool2d</p>
</dd>
<dt>uint8:</dt><dd><p>Composite: cast(int32), nn.avg_pool2d, cast(uint8)</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-even"><td><p>power(of 2) +
nn.avg_pool2d +
sqrt</p></td>
<td><p>A special case for L2 pooling.</p>
<dl class="simple">
<dt>fp32:</dt><dd><p>Composite: power(of 2), nn.avg_pool2d, sqrt</p>
</dd>
</dl>
</td>
</tr>
<tr class="row-odd"><td><p>reshape</p></td>
<td><p>fp32, uint8</p></td>
</tr>
<tr class="row-even"><td><p>maximum</p></td>
<td><p>fp32</p></td>
</tr>
<tr class="row-odd"><td><p>add</p></td>
<td><p>fp32</p></td>
</tr>
<tr class="row-even"><td><p>qnn.add</p></td>
<td><p>uint8</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">注解</p>
<p>A composite operator is a series of operators that map to a single Arm Compute Library operator. You can view this
as being a single fused operator from the view point of Arm Compute Library. ‘?’ denotes an optional operator in
the series of operators that make up a composite operator.</p>
</div>
</div>
<div class="section" id="adding-a-new-operator">
<h2>Adding a new operator<a class="headerlink" href="#adding-a-new-operator" title="永久链接至标题">¶</a></h2>
<p>Adding a new operator requires changes to a series of places. This section will give a hint on
what needs to be changed and where, it will not however dive into the complexities for an
individual operator. This is left to the developer.</p>
<p>There are a series of files we need to make changes to:</p>
<ul class="simple">
<li><p><cite>python/relay/op/contrib/arm_compute_lib.py</cite> In this file we define the operators we wish to offload using the
<cite>op.register</cite> decorator. This will mean the annotation pass recognizes this operator as ACL offloadable.</p></li>
<li><p><cite>src/relay/backend/contrib/arm_compute_lib/codegen.cc</cite> Implement <cite>Create[OpName]JSONNode</cite> method. This is where we
declare how the operator should be represented by JSON. This will be used to create the ACL module.</p></li>
<li><p><cite>src/runtime/contrib/arm_compute_lib/acl_runtime.cc</cite> Implement <cite>Create[OpName]Layer</cite> method. This is where we
define how the JSON representation can be used to create an ACL function. We simply define how to
translate from the JSON representation to ACL API.</p></li>
<li><p><cite>tests/python/contrib/test_arm_compute_lib</cite> Add unit tests for the given operator.</p></li>
</ul>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">tvm-cn</a></h1>








<h3>导航</h3>
<p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html">安装 TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute/index.html">Contributor Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">User Guide</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">How To Guides</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dev/tutorial/index.html">Developer Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../dev/how_to/how_to.html">Developer How-To Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">Architecture Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../arch/index.html">Design and Architecture</a></li>
</ul>
<p class="caption"><span class="caption-text">Topic Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../topic/microtvm/index.html">microTVM: TVM on bare-metal</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../topic/vta/index.html">VTA: Versatile Tensor Accelerator</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">How To Guides</a><ul>
  <li><a href="index.html">Deploy Models and Integrate TVM</a><ul>
      <li>Previous: <a href="hls.html" title="上一章">HLS Backend Example</a></li>
      <li>Next: <a href="tensorrt.html" title="下一章">Relay TensorRT Integration</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, HyperAI.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/how_to/deploy/arm_compute_lib.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>